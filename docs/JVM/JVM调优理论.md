# JVM调优理论
## 术语解释

### Session复制

Session复制是指在分布式系统中，将用户会话(Session)数据从一台服务器复制到另外一台服务器的过程。例如：传统的单体服务环境中，用户的会话数据存储在服务器的本地内存中，在分布式系统中，用户的请求被负载均衡器分发到不同的服务器上，为了确保用户在整个应用程序的体验一致性，特别是在会话数据共享，所采取的Session复制策略。

Session复制实现的两种方式：

1. 基于Session的负载均衡：这种方式通过负载均衡器将用一用户的所有请求都路由到一台服务器，从而保持用户的会话状态在用一服务器。可能导致服务器负载不均衡。
2. 会话共享：将用户的会话数据从一个服务器复制到另外一个服务器。可以通过分布式缓存、数据库存储等方式实现。



nginx实现基于Session的负载均衡配置：

~~~conf
http {
	// 被代理的服务器
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server backend3.example.com;
    }

    server {
        listen 80;

        location / {
            ip_hash;  # 启用ip_hash模块，基于客户端IP哈希分配
            proxy_pass http://backend;
        }
    }
}

~~~



### 亲合式集群

亲合式集群指在分布式系统中的一种策略，其中具有相关性或关联性的任务或数据被分配到同一组或集群中。这可以增加系统性能、降低延迟，并提高数据访问的效率。



### WebLogic

WebLogic是Oracle提供的一套企业级Java应用服务器(Java EE Application Server)中间件产品。它是一个强大的中间件平台，用于构建、部署和管理企业级应用程序。



### 安全点

在Java进行垃圾回收时，垃圾回收器通常需要暂停正在执行的Java应用程序的线程，以确保一致性和安全性。这个暂停的点被称为安全点（Safepoint）。在安全点，Java虚拟机确保对象的一致性，执行垃圾回收和其他一些需要线程安全的操作。

- 方法调用：安全点通常发生在方法调用的时候，即当线程执行java方法的入口或出口(return)。
- 循环跳转：每次循环的开始或结束。
- 异常抛出：在抛出异常是，也可能作为安全点。





## 案例分析

### 大内存硬件上的程序部署策略

如果在一台大内存服务器上部署一个Java程序，所选用的虚拟机不是最新的高性能垃圾收集器，可能会面临一些问题：当程序运行过程中出现了Full GC，可能导致程序的停止时间过长。

部署单个应用程序：

能保证在大内存上部署单个应用程序，保证Full GC频次较低，要保证用户使用过程中不能发生GC，例如：十几小时到一整天不发生GC，可以通过用户不怎么使用的流量点，去触发Full GC或者重启应用。出现Full GC的关键是，老年的对象要稳定，要保证进入老年代的对象基本上是能够一直存活的，也就是新生代的对象基本上是朝生夕灭的。在这种情况下，大内存服务器部署单台服务器不会出现太大的问题。



部署多个应用程序：

可以搭建一个前置负载均衡器，将这个应用在服务器启动多个建立一个无Session复制的亲合式集群。这个每个应用所占用的堆内存就不会太高，这样进行垃圾收集时，停顿的时间也不会太长。这样也会有一些缺点：有使用本地缓存，会导致内存的浪费。



### 堆外内存溢出

堆外内存溢出，配置了-XX:+HeapDumpOnOutOfMemoryError参数，可能也不会生成dump文件。但是系统日志里面可能会打印发生的相关信息。堆外内存的回收不像堆内内存回收一样，是程序通知其要垃圾收集，而是Full GC出现顺带回收。

-XX:+DisableExplicitGC 关闭人工触发垃圾收集。

-XX:MaxDirectMemorySize设置直接内存大小。



### 虚拟机进程崩溃

一个服务器A的请求存在异步调用另外一台服务器B，这里的调用使用了异步的方式。当被异步调用的服务器响应时间非常慢时，而这是A的请求还在源源不断的进来，它会不断的异步去调用B服务器，这时等待的线程和Socket连接也会越来越多，就可能超过虚拟机的承受能力，导致进程崩溃。个人认为出现这种情况：还需要这个每次的异步调用可能都会开启线程，并没有使用线程池的策略。



### 不恰当的垃圾收集导致停顿时间过长

深入理解JVM虚拟机案例：

启动参数：-Xmn1g -Xms4g -Xmx8g。一个程序会每10分钟在内存中创建100万个HashMap<Long,Long>对象(会占用800MB内存)，这个时候垃圾收集器的Minor GC会造成500毫秒的停顿，出现这种收集时间长的问题，应该和新生代的对象复制到老年代有关，应该是发生GC时这800MB对象没有被回收，而是被复制到老年代，才导致停顿时间这么长。

解决方法：

1. 将新生代内存扩大，保证MinorGC会将这个800MB对象不会进入老年代。
2. 将对象之间进入老年代，最终会面临一个Full GC，停顿时间也不会短。



启动参数：-Xmn1g -Xms4g -Xmx8g -XX:+UseParNewGC -XX:+PrintGCDetails 

![image-20240106205820408](http://47.101.155.205/image-20240106205820408.png)

模拟800MB对象加载和被垃圾对象回收

![image-20240106210022649](http://47.101.155.205/image-20240106210022649.png)

启动参数：-Xmn2g -Xms4g -Xmx8g -XX:+UseParNewGC -XX:+PrintGCDetails，扩大新生代内存空间。

![image-20240106210222161](http://47.101.155.205/image-20240106210222161.png)

启动参数：-Xmn1g -Xms4g -Xmx8g -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0 -XX:+UseParNewGC -XX:+PrintGCDetails 将对象之间存放老年代。

![image-20240106210930057](http://47.101.155.205/image-20240106210930057.png)



总结：你不能保证每次进行对象被标记回收和重新加载之前执行。如果出现对象被加载到老年代，就会面临停顿时间长的问题。可以通过在对象设为null的情况下，System.gc()手动回收一下，这样GC时间就不会太长。

![image-20240106210654924](http://47.101.155.205/image-20240106210654924.png)



### 避免安全点前出现耗时操作

安全点导致停顿超时案例：https://juejin.cn/post/6844903878765314061

| 参数                                | 作用            |
| ----------------------------------- | --------------- |
| -XX:+PrintGCApplicationStoppedTime  | 打印STW停顿时间 |
| -XX:+PrintSafepointStatistics       |                 |
| -XX:PrintSafepointStatisticsCount=1 |                 |
| -XX:+SafepointTimeout               |                 |
| -XX:SafepointTimeoutDelay=2000      |                 |





## IDEA编辑器实战分析

### IDEA启动没有JVM进程

使用jps -l查询所有Java启动的JVM进程id，发现没有之前IDEA启动的类，说明可能是出现了什么问题。



![image-20240107170107899](http://47.101.155.205/image-20240107170107899.png)



IDEA插件开发文档：https://plugins.jetbrains.com/docs/intellij/welcome.html?from=jetbrains.org

