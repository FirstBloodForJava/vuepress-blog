# 数据结构

数据结构可以分为两大类：

- 线性结构：数据元素之间是一对一的关系。
- 非线性结构：数据元素之间存在一对多或多对多关系。

**线性结构：**

1. 数组：元素连续存储。支持随机访问O(1)；删除代价较高O(n)。
2. 链表：元素通过指针连接。访问慢O(n)；插入、删除效率高（O(1)，若已定位）。单向链表、双向链表、循环链表。
3. Hash表：数组+链表。时间复杂度O(1)，最坏O(n)。
4. 栈：先进后出。
5. 队列：先进先出。双端队列、优先队列、循环队列。

**非线性结构：**

1. 树：层级节点，每个节点最多只有一个父节点，多个子节点。二叉树、二叉搜索树（BST）；平衡二叉树（AVL）、红黑树；堆（大顶堆/小顶堆）；B树、B+树。
2. 图：节点和边的集合。



## 树

树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。

每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。

- 节点的度：一个节点含有子节点的数量
- 叶节点或终端节点：度为零的节点
- 分支节点或非终端节点：度不为零的节点
- 双亲节点或父节点：一个节点含有子节点，则这个节点为此节点的父节点
- 兄弟节点：具有相同父节点的节点互称兄弟节点
- 树的度：一棵树中，最大的节点的度称为树的度
- 节点的层次：从根节点算第一层，根的子节点为第二层，一次类推
- 树的高度或深度：树中节点的最大层次
- 堂兄弟节点：双亲在同一层级的节点
- 节点的祖先：从根到该节点所经分支上的所有节点
- 子孙：以一个节点为根的子树中的任一节点都称为该节点的子孙
- 森林：由m(m > 0)颗互不相交的树的集合称为森林



**树的种类：**

- 无序树：树种任意节点的子节点之间没有顺序关系。
- 有序树：树种任意节点的子节点之间有顺序关系。
- 二叉树：每个节点最多含有两个节点的树。
- 满二叉树：叶节点除外，所有的节点均含有两个节点。
- 完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树
- 哈夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树。





### 二叉树

二叉树是n个有限元素的集合，该集合为空、或者由一个根的元素和两个不相交的子树组成，是有序树。

二叉树(binary tree)是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。

二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。

集合为空时，二叉树也称为空二叉树，在二叉树中，每个元素也称为一个节点。

二叉树特点：每个节点最多只能有两颗子树组成，且有左右之分。

- 空二叉树
- 只有一个根节点的二叉树
- 只有左子树
- 只有右子树
- 完全二叉树





### 红黑树



### B-Tree

对于一棵m阶B-tree，每个结点至多可以拥有m个子结点。各结点的关键字和可以拥有的子结点数都有限制，规定m阶B-tree中，根结点至少有2个子结点，除非根结点为叶子节点(又称为终端节点，一棵树没有子节点，即度为0)，相应的，根结点中关键字的个数为1~m-1；非根结点至少有[m/2]（[]，向上取整）个子结点，相应的，关键字个数为[m/2]-1~m-1。

B-Tree中，每个节点包含：

- 本节点所含的关键字的个数；
- 指向父节点的指针；
- 关键字；
- 指向子节点的指针。



### B+Tree

其节点结构与B-tree相同，不同的是各结点的关键字和可以拥有的子结点数。如m阶B+树中，每个结点至多可以拥有m个子结点。非根结点至少有[m/2]个子结点，而关键字个数比B-tree多一个，为[m/2]~m。

B+和B-（即B）是因为每个结点上的关键字不同。一个多一个，一个少一个。



### 堆

堆(Heap)是一种基于树的数据结构，通常用于实现优先队列(最高效)。堆具有以下特性：

1. 堆的物理结构本质上是顺序存储的，是线性的(数组是线性的)。但在逻辑上不是线性的，是完全二叉树的这种逻辑储存结构
2. 堆序特性：堆是一个完全二叉树(除了最顶层，其他层都是满的，最底层从左到右填入)；对于堆中的任一节点的值，都是不大于或不小于其父节点的值。即：![image-20240326141630209](http://47.101.155.205/image-20240326141630209.png)

自上而下堆化：

~~~java
void add(int e){
	if (size == queue.length - 1){
		// 扩容
		queue = Arrays.copyOf(queue, 2 * queue.length);
    }
	queue[++size] = e;
	fixedUp(size);
}

private void fixedUp(int k){
	// 写法一
	while (k > 1){
		int j = k >> 1;
		if (queue[j] <= queue[k]){
		// 小顶堆 i表示堆中数组下标,则满足queue[i] <= queue[2*i] queue[i] <= queue[2*i + 1]
		// 其中j表示的就是i
        	break;
    	}
    	int temp = queue[k];
		queue[k] = queue[j];
		queue[j] = temp;
        k = j;
    }
	// 写法二
	while (k > 1 && queue[k >> 1] > queue[k]){
        int temp = queue[k >> 1];
		queue[k >> 1] = queue[k];
		queue[k] = temp;
		k = k >> 1;
    }
}

~~~

移除堆顶元素：

~~~java
void removeTop(){
	queue[1] = queue[size];
    queue[size--] = 0;
    fixedDown(1);
}

private void fixedDown(int k){
    int j;
    while ((j = k << 1) <= size && j > 0){
        // 子节点中取出最小的比较
        if (j < size && queue[j] > queue[j+1]){
            j++;
        }
        // 直到父节点 小于等于 子节点的最小
        if (queue[k] <= queue[j]){
			break;
        }
        int temp = queue[j];
        queue[j] = queue[k];
        queue[k] = temp;
		k = j;
    }
}

~~~

**将数组堆化：**

假设这是一个满堆(最底层的节点都是满的)，元素为n个，堆高h则为log2(n+1) - 1，即：

1个元素时，堆高0；3个元素时，堆高1；

7个元素时，堆高2；15个元素时，堆高3；

从底层往上层堆化：

倒数第二层和倒数第一次进行一次比较，比较层级1，倒数第二次比较元素不超过2的h-1次幂；

倒数第三层和倒数第二层，倒数第一层比较，比较层级是2，元素不超过2的h-2次幂；

第一层，比较层级是h-1,元素个数是2；

顶层，比较层级是h，元素个数是1；

对于h大于等于2的即n大于等于7的，时间复杂度则满足下面的等式：

S = 2^(h-1) x 1+ 2^(h-2) x 2 + 2^(h-3)x3 + ... + 2x(h-1) + 1 x h

2S = 2^h + 2^(h-1) x 2 + 2^(h-2)x3 + ... + 2^2x(h-1) + 2^1* h

错位相减得到：S=2^h + 2^(h-1) + ...+2^2 + 2 -h = 2^(h + 1) - 1 - h = n - log2(n+1) - 1

所以时间复杂度是n

![image-20240327220437422](http://47.101.155.205/image-20240327220437422.png)

~~~java
// size 为数组下标1开始的元素个数
void heapify(){
	for (int i = size/2; i >= 1; i--) {
        fixedDown(i);
    }
}

private void fixedDown(int k){
    int j;
    while ((j = k << 1) <= size && j > 0){
        // 子节点中取出最小的比较
        if (j < size && queue[j] > queue[j+1]){
            j++;
        }
        // 直到父节点 小于等于 子节点的最小
        if (queue[k] <= queue[j]){
			break;
        }
        int temp = queue[j];
        queue[j] = queue[k];
        queue[k] = temp;
		k = j;
    }
}

~~~

