# 数学

## 充分必要条件

如果命题 p 能推出命题 q，且命题 q 也能推出命题 p，则称 p 是 q 的充分必要条件，且 q 也是 p 的充分必要条件。

p 能推出 q，p 是 q 的充分条件；q 是否能推出 p 决定了 p 和 q 的必要条件关系。

- q 不能推出 p，则 p 是 q 的充分不必要条件。
- q 能推出 p，则 p 是 q 的充分必要条件。



## 集合

集合用二进制表示，二进制第 i 位为 1 表示在集合中，为 0 表示不在集合中。例如集合{0,2,3} 可以用二进制 `1101` 表示。非负整数的的集合可以压缩成一个数字。可以使用位运算高效的做一些集合有关的运算。



**集合与集合**

- 对称差：集合 A 与集合 B 中所有不属于 A ∩ B 的元素的集合。
- 差：A - B，属于 A 但是不属于 B 的的所有元素组成的集合，`A - B == ∅`(空集)，说明 A 是 B 的子集。



| 术语       | 集合         | 位运算                    | 集合示例                  | 位运算示例                                  |
| ---------- | ------------ | ------------------------- | ------------------------- | ------------------------------------------- |
| 交集       | A ∩ B        | a & b                     | {0,2} ∩ {0,2,3} = {0,2}   | 0101 & 1101 = 0101                          |
| 并集       | A ∪ B        | a \| b                    | {0,2} ∩ {0,2,3} = {0,2,3} | 0101 \| 1101 = 1101                         |
| 对称差     | A △ B        | a ^ b                     | {0,2} △ {0,2,3} = {3}     | 0101 ^ 1101 = 1000                          |
| 差         | A - B        | a & ~b                    | {0,2,3} - {0,1} = {2,3}   | 1101 & 1100 =1100                           |
| 差（子集） | A - B, B ⊆ A | a ^ b                     | {0,2,3} - {0,2} = {3}     | 0101 ^ 1101 = 1000                          |
| 包含于     | A ⊆ B        | a & b = a<br />a \| b = b | {0,2} ⊆ {0,2,3}           | 0101 & 1101 = 0101<br />0101 \| 1101 = 1101 |



**集合与元素**

补集：A 和 B 是集合，则 A 在 B 中的相对补集，集合元素属于 B 但是不属于 A。

| 术语                 | 集合                | 位运算             | 集合示例                           | 位运算示例              |
| -------------------- | ------------------- | ------------------ | ---------------------------------- | ----------------------- |
| 空集                 | ∅                   | 0                  |                                    |                         |
| 单元素集合           | {i}                 | 1 << i             | {2}                                | 1 << 2                  |
| 全集                 | U = {0,1,2,...,n-1} | (1 << n) - 1       | {0,1,2,3}                          | (1<<4) - 1<br />1111    |
| 补集                 | CuA                 | ((1 << n) - 1) ^ a | U = {0,1,2,3}<br />Cu{0,1} = {2,3} | 1111 ^ 0011 = 1100      |
| 属于                 | i ∈ S               | (s >> i) & 1 == 1  | 2 ∈ {0,2,3}                        | (1101 >> 2) & 1 == 1    |
| 不属于               | i /∈ S              | (s >> i) & 1 == 0  | 1 /∈ {0,2,3}                       | (1101 >> 1) & 1 == 0    |
| 添加元素             | S ∪ {i}             | s \| (1 << i)      | {0,3} ∪ {2}                        | 1001 \| (1 << 2) = 1101 |
| 删除元素             | S / {i}             | s & ~(1 << i)      | {0,2,3} / {2}                      | 1101 & ~(1 << 2)        |
| 删除元素，i 在集合中 | S / {i}, i ∈S       | s ^ (1 << i)       | {0,2,3} / {2}                      | 1101 ^ (1 << 2)         |
| 删除最小元素         |                     | s & (s - 1)        | {0,2,3}                            | 1101 & (1100)           |



二进制库函数：

| 术语         | java                                              |
| ------------ | ------------------------------------------------- |
| 集合大小     | Integer.bitCount(s)                               |
| 二进制长度   | 32 - Integer.numberOfLeadingZeros(s)              |
| 集合最大元素 | 31 - Integer.numberOfLeadingZeros(s)，-1 表示空集 |
| 集合最小元素 | Integer.numberOfTrailingZeros(s)，32 表示空集     |



`lowbit` 只包含最小元素的子集，即二进制的最低位 1 及后面的 0，`s & -s`

~~~md
s  	   = 100100
~s     = 011011
(~s)+1 = 011100
s & -s = 000100

~~~





## GCD

求两个数的最大公约数（最大公因数）。

**辗转相除法**：通过反复用余数替换较大数，直到余数为 0，此时的**除数**就是最大公约数。


~~~java
public int gcd(int a, int b) {
    // a > 0, b > 0;
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
~~~

**更相减损法**：通过反复用两个数的差替换较大数，直到两数相等，这个相等数就是最大公约数。

如果两个数都是偶数，可以先除以 2 进行化简，同时记录除以 2 的次数。

~~~java
public int gcd(int a, int b) {
    // a > 0, b > 0;
    int factor = 1;
    while ((a & 1) == 0 && (b & 1) == 0) {
        a >>= 1;
        b >>= 1;
        factor <<= 1;
    }
    while (a != b) {
        if (a > b) {
            a = a - b;
        } else {
            b = a - b;
        }
    }
    return a * factor;
}
~~~



## 上取整下取整公式转换证明

$$

\text{a 为非负整数, b 为正整数:} \lceil \frac{a}{b} \rceil = \lfloor \frac{a + b - 1}{b} \rfloor \\
\text{分类讨论证明:} \\
\text{当 a mod b = 0: } 
\lceil \frac{a}{b} \rceil  = \lfloor \frac{a + b - 1}{b} \rfloor 
= \lfloor \frac{a}{b} + \frac{b-1}{b} \rfloor
= \frac{a}{b} + \lfloor \frac{b-1}{b} \rfloor
= \frac{a}{b} \text{ 等式恒成立} \\
\text{当 a mod b > 0: }
\lceil \frac{a}{b} \rceil  = \lfloor \frac{a + b - 1}{b} \rfloor 
= \lfloor \frac{a-1}{b} + \frac{b}{b} \rfloor
= \lfloor \frac{a-1}{b} \rfloor + 1 \text{ 等式恒成立}
$$



