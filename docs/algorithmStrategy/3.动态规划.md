---
permalink: /algorithmStrategy/dp.html
title: 动态规划
---





## 算法思想

动态规划(Dynamic Programming，DP)算法采用分治算法的思想，将原问题分成若干个子问题，然后风别求解各个子问题，最后将子问题的解组合起来得到原问题的解。分治算法递归的求解各个子问题，可能重复求解某些子问题。与分治算法不同的是，动态规划不是递归地求解各个子问题，它是从简单问题的解入手，逐步求解，直到求解出原问题。

动态规划算法的高明之处在于，它不会重复求解某些重复出现的子问题，即重叠子问题。

计算Fibonacci序列F(n)

~~~md
n=0 or n=1 => F(n) = 1;
n>1 => F(n) = F(n-1) + F(n-2);

~~~

~~~java
// 递归实现，时间复杂度O(2^n)
int f(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return f(n-1) + f(n-2);
    }
}

~~~

递归过程图



记忆化优化

~~~java
int[] fn = new int[n+1];
int f(int n) {
    if (n <= 1) return 1;
    // 取记忆集
    if (fn[n] != 0) return fn[n];
    // 记录结果集
    fn[n] = f(n-1) + f(n-2);
    
    return fn[n];
}

~~~





~~~java
// 迭代算法，时间复杂度：O(n)
int f(int n) {
    int[] fn = new int[n];
    fn[0] = 1;
    fn[1] = 1;
    for(i = 2; i <= n; i++) {
        fn[i] = fn[i-1] + fn[i-2];
    }
    return fn[n];
}

~~~

迭代设计步骤：

1. 构造原问题和子问题之间的递归方程，F(n) = F(n-1) + F(n-2)；
2. 将求出的子问题结果保存，继续求后续的子问题；
3. 以递归出口作为计算的出口，自底向上的求出结果，这样保证了当在解决一个问题时，所有比该问题更小的子问题的解就已经得到了(数组中)，这样就可以用这个解继续求接下来的问题。



动态规划算法常用来求解最优化问题，设计一个动态规划算法常用步骤：

1. 找出最优解的结构；
2. 递归定义一个最优解的值；
3. 以自底向上的方式计算出最优解的值；
4. 根据计算最优解的值的信息，构造一个最优解。



## 算法应用



### 最长公共子序列问题





### 0/1背包问题



### 最优二叉搜索树问题