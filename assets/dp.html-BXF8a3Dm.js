import{_ as s,c as a,e as p,o as t}from"./app-BIGZvh4f.js";const e={};function l(o,n){return t(),a("div",null,n[0]||(n[0]=[p(`<h2 id="算法思想" tabindex="-1"><a class="header-anchor" href="#算法思想"><span>算法思想</span></a></h2><p>动态规划(Dynamic Programming，DP)算法采用分治算法的思想，将原问题分成若干个子问题，然后风别求解各个子问题，最后将子问题的解组合起来得到原问题的解。分治算法递归的求解各个子问题，可能重复求解某些子问题。与分治算法不同的是，动态规划不是递归地求解各个子问题，它是从简单问题的解入手，逐步求解，直到求解出原问题。</p><p>动态规划算法的高明之处在于，它不会重复求解某些重复出现的子问题，即重叠子问题。</p><p>计算Fibonacci序列F(n)</p><div class="language-markdown" data-highlighter="prismjs" data-ext="md" data-title="md"><pre><code><span class="line">n=0 or n=1 =&gt; F(n) = 1;</span>
<span class="line">n&gt;1 =&gt; F(n) = F(n-1) + F(n-2);</span>
<span class="line"></span>
<span class="line"></span></code></pre></div><div class="language-java" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 递归实现，时间复杂度O(2^n)</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>递归过程图</p><p>记忆化优化</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 取记忆集</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>fn<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> fn<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 记录结果集</span></span>
<span class="line">    fn<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">return</span> fn<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 迭代算法，时间复杂度：O(n)</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    fn<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    fn<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        fn<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fn<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> fn<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> fn<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代设计步骤：</p><ol><li>构造原问题和子问题之间的递归方程，F(n) = F(n-1) + F(n-2)；</li><li>将求出的子问题结果保存，继续求后续的子问题；</li><li>以递归出口作为计算的出口，自底向上的求出结果，这样保证了当在解决一个问题时，所有比该问题更小的子问题的解就已经得到了(数组中)，这样就可以用这个解继续求接下来的问题。</li></ol><p>动态规划算法常用来求解最优化问题，设计一个动态规划算法常用步骤：</p><ol><li>找出最优解的结构；</li><li>递归定义一个最优解的值；</li><li>以自底向上的方式计算出最优解的值；</li><li>根据计算最优解的值的信息，构造一个最优解。</li></ol><h2 id="算法应用" tabindex="-1"><a class="header-anchor" href="#算法应用"><span>算法应用</span></a></h2><h3 id="最长公共子序列问题" tabindex="-1"><a class="header-anchor" href="#最长公共子序列问题"><span>最长公共子序列问题</span></a></h3><h3 id="_0-1背包问题" tabindex="-1"><a class="header-anchor" href="#_0-1背包问题"><span>0/1背包问题</span></a></h3><h3 id="最优二叉搜索树问题" tabindex="-1"><a class="header-anchor" href="#最优二叉搜索树问题"><span>最优二叉搜索树问题</span></a></h3>`,18)]))}const i=s(e,[["render",l],["__file","dp.html.vue"]]),u=JSON.parse('{"path":"/algorithmStrategy/dp.html","title":"动态规划","lang":"zh-CN","frontmatter":{"permalink":"/algorithmStrategy/dp.html","title":"动态规划"},"headers":[{"level":2,"title":"算法思想","slug":"算法思想","link":"#算法思想","children":[]},{"level":2,"title":"算法应用","slug":"算法应用","link":"#算法应用","children":[{"level":3,"title":"最长公共子序列问题","slug":"最长公共子序列问题","link":"#最长公共子序列问题","children":[]},{"level":3,"title":"0/1背包问题","slug":"_0-1背包问题","link":"#_0-1背包问题","children":[]},{"level":3,"title":"最优二叉搜索树问题","slug":"最优二叉搜索树问题","link":"#最优二叉搜索树问题","children":[]}]}],"git":{"updatedTime":1730982824000,"contributors":[{"name":"oycm","username":"oycm","email":"1164864987@qq.com","commits":2,"url":"https://github.com/oycm"}]},"filePathRelative":"algorithmStrategy/3.动态规划.md"}');export{i as comp,u as data};
