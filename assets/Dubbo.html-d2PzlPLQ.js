import{_ as o,c as r,e as n,o as a}from"./app-BIGZvh4f.js";const i={};function b(t,e){return a(),r("div",null,e[0]||(e[0]=[n('<h1 id="dubbo" tabindex="-1"><a class="header-anchor" href="#dubbo"><span>Dubbo</span></a></h1><p><a href="https://dubbo.apache.ac.cn/en/overview/" target="_blank" rel="noopener noreferrer">Dubbo 文档</a></p><h2 id="dubbo简介" tabindex="-1"><a class="header-anchor" href="#dubbo简介"><span>Dubbo简介</span></a></h2><p>Apache Dubbo 是一个 RPC 服务开发框架，用于解决微服务架构下的服务治理和通信问题。</p><p>Dubbo3 被定义为面向云原生下一代 RPC 服务框架。3.0 在 Dubbo 2.x 的基础上进行了演进。在保持原有核心特性的同时，Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配和安全方面都有所提升。</p><figure><img src="http://47.101.155.205/image-20250705091358985.png" alt="image-20250705091358985" tabindex="0" loading="lazy"><figcaption>image-20250705091358985</figcaption></figure><p>Dubbo 是一个 RPC 框架，它定义了自己的 RPC 通信协议和编程方式。使用 Dubbo 时，用户首先需要<strong>定义 Dubbo 服务</strong>；其次，将 <strong>Dubbo 服务部署上线</strong>后，依靠 Dubbo 的<strong>应用层通信协议</strong>实现数据交换，Dubbo 传输的数据必须进行序列化。而这里的序列化协议是完全可扩展的。Dubbo 中的服务定义是一组完成业务功能的方法。您可以选择以绑定到特定语言的方式定义它们。从服务消费者 (Consumer) 的角度来看，可以通过调用 Dubbo 框架提供的 API 获取<strong>服务代理 (stub) 对象</strong>，然后像调用本地服务一样调用服务方法。消费者发起对服务方法的调用后，Dubbo <strong>框架</strong>负责将请求发送到部署在<strong>远程机器上的服务提供者</strong>。</p><figure><img src="http://47.101.155.205/image-20250705092730798.png" alt="image-20250705092730798" tabindex="0" loading="lazy"><figcaption>image-20250705092730798</figcaption></figure><p>在分布式系统中，特别是随着微服务架构的发展，应用的部署、发布和扩展变得极其频繁。作为 RPC 消费者，如何<strong>动态发现服务提供者的地址</strong>成为 RPC 通信的先决条件。Dubbo 提供<strong>自动地址发现机制</strong>，用于处理分布式场景下机器实例的动态迁移。通过<strong>引入注册中心</strong>来<strong>协调提供者和消费者的地址</strong>。提供者启动后，将自己的地址注册到注册中心，消费者通过<strong>拉取或订阅注册中心</strong>中特定节点动态感知提供者的地址列表变化。</p><h3 id="dubbo核心特性" tabindex="-1"><a class="header-anchor" href="#dubbo核心特性"><span>Dubbo核心特性</span></a></h3><p><strong>高性能 RPC 通信协议</strong></p><p>跨<strong>进程</strong>或<strong>主机</strong>之间的服务通信是 Dubbo 的基本能力。Dubbo RPC 以预定义的协议编码方式将请求数据 (Request) 发送到后端服务，并接收服务器返回的结果 (Response)。RPC 通信对用户完全透明，用户无需关心请求是如何发送的以及发送到哪里，只需要获取每次调用的正确调用结果即可。除了同步模式下的 Request-Response 通信模型，Dubbo3 还提供了更丰富的通信模型选择：</p><ul><li>消费者端异步请求 (Client Side Asynchronous Request-Response)</li><li>提供者端异步执行 (Server Side Asynchronous Request-Response)</li><li>消费者请求流 (Request Streaming)</li><li>提供者响应流 (Response Streaming)</li><li>双向流式传输</li></ul><p><strong>自动服务（地址）发现</strong></p><p>Dubbo 的服务发现机制允许微服务组件独立演进，任意部署，消费者无需知道对端的部署位置和 IP 地址即可完成通信。Dubbo 提供 Client-Based 服务发现机制，用户可以通过<strong>多种方式</strong>启用<strong>服务发现</strong>：</p><ul><li>使用独立的注册中心组件，例如 Nacos、Zookeeper、Consul、Etcd 等。</li><li>将服务的组织和注册交给底层容器平台，例如 Kubernetes，这被理解为更云原生的使用方式</li></ul><p><strong>运行状态流量控制</strong></p><p>透明地址发现允许 Dubbo 请求发送到任何 IP 实例，在这个过程中流量会被随机分配。当需要更丰富、更细粒度的流量控制时，可以使用 Dubbo 的流量控制策略。Dubbo 提供了负载均衡、流量路由、请求超时、流量降级、重试等策略，基于这些基本能力，您可以轻松实现更多场景化的路由解决方案，包括金丝雀发布、A/B 测试、权重路由、同区域优先等。Dubbo 支持流量控制策略在运行状态下动态生效，无需重新部署。</p><ul><li><a href="https://dubbo.apache.ac.cn/en/overview/tasks/traffic-management/" target="_blank" rel="noopener noreferrer">流量管理示例</a></li></ul><p><strong>丰富的扩展组件和生态</strong></p><p>Dubbo 强大的服务治理能力不仅体现在核心框架中，还包括其出色的扩展能力以及周边配套设施的支持。通过定义几乎存在于每个关键流程中的扩展点，例如 Filter、Router 和 Protocol，我们可以丰富 Dubbo 的功能或实现与其他微服务支持系统的连接，包括 Transaction 和 Tracing。</p><ul><li><a href="https://dubbo.apache.ac.cn/en/overview/what/ecosystem/" target="_blank" rel="noopener noreferrer">Dubbo 生态系统</a></li><li><a href="https://dubbo.apache.ac.cn/en/overview/what/extensibility/" target="_blank" rel="noopener noreferrer">Dubbo 扩展性设计</a></li></ul><p><strong>Kubernetes</strong></p><p>为了让 Dubbo 微服务支持 Kubernetes 平台调度，最基本的是要实现 dubbo 服务生命周期与容器生命周期的对齐，包括 Dubbo 启动、销毁和服务注册等生命周期事件。与过去 Dubbo 自行定义生命周期事件，并要求开发者在运维实践中遵守协议不同，Kubernetes 的底层基础设施定义了严格的组件生命周期事件 (probes)，而是要求 Dubbo 按照协议进行适配。</p><p>Kubernetes Service 是另一个层面的适配，它反映了服务定义和注册下沉到云原生底层基础设施的趋势。在这种模式下，用户不再需要构建额外的注册中心组件，Dubbo 消费者端节点可以自动连接到 Kubernetes (API-Server 或 DNS)，并根据<strong>服务名称</strong> (Kubernetes Service Name) 查询实例列表 (Kubernetes endpoints)。此时，服务通过标准的 <code>Kubernetes Service API</code> 定义并分发到每个节点。</p><p><strong>Dubbo Mesh</strong></p><p>Service Mesh 在业界已经得到了广泛的传播和认可，被认为是下一代微服务架构，主要是因为它解决了包括透明升级、多语言、依赖冲突和流量管理等许多难题。Service Mesh 的典型架构是通过部署独立的 Sidecar 组件来拦截所有出站和入站流量，并在 <code>Sidecar</code> 中集成负载均衡和路由等丰富的流量管理策略。此外，Service Mesh 还需要一个控制平面 (Control Panel) 来实现对 Sidecar 流量的控制，即发布各种策略。我们在这里将这种架构称为 <code>Classic Mesh</code>。</p><p>没有技术架构是完美的，Classic Mesh 也面临着实现层面的高成本问题：</p><ol><li>需要运维控制面板 (Control Panel)</li><li>需要操作和维护 Sidecar</li><li>需要考虑如何从原有的 SDK 迁移到 Sidecar</li><li>需要考虑引入 Sidecar 后整个链路的性能损失</li></ol><p>为了解决 Sidecar 带来的相关成本问题，Dubbo 引入并实现了新的 <code>Proxyless Mesh</code> 架构。顾名思义，Proxyless Mesh 指的是不部署 Sidecar，Dubbo SDK 直接与控制平面交互。</p><figure><img src="http://47.101.155.205/image-20250705103327043.png" alt="image-20250705103327043" tabindex="0" loading="lazy"><figcaption>image-20250705103327043</figcaption></figure><p>在不同的组织和不同的开发阶段，使用 Dubbo 构建的微服务未来将允许三种部署架构：传统的 SDK、基于 Sidecar 的 Service Mesh 以及不带 Sidecar 的 Proxyless Mesh。基于 Sidecar 的 Service Mesh，即 Classic Mesh 架构，独立的 Sidecar 运行时接管所有流量，与 Sidecar 的 Proxyless Mesh 相分离，二级 SDK 通过 <code>xDS</code> 直接与控制平面通信。Dubbo 微服务允许部署在物理机、容器和 Kubernetes 平台上，可以使用 Admin 作为控制平面，并使用统一的流量治理规则对其进行管理。</p><h2 id="简单使用" tabindex="-1"><a class="header-anchor" href="#简单使用"><span>简单使用</span></a></h2><h3 id="dubbo-api" tabindex="-1"><a class="header-anchor" href="#dubbo-api"><span>Dubbo-API</span></a></h3><p><a href="https://dubbo.apache.ac.cn/en/docs3-v2/java-sdk/reference-manual/config/api/" target="_blank" rel="noopener noreferrer">dubbo-api 文档</a></p><p><a href="https://github.com/FirstBloodForJava/dubbo-api-demo.git" target="_blank" rel="noopener noreferrer">gitbub api例子</a></p><p>步骤：</p><ol><li>启动注册中心，这里使用ZooKeeper；</li><li>项目初始化，添加需要的maven依赖。</li><li>定义服务接口；</li><li>服务提供者实现接口；</li><li>服务发布；</li><li>消费者订阅接口并调用；</li><li>启动服务服务提供者，启动消费订阅者。</li></ol><h3 id="dubbo-springboot" tabindex="-1"><a class="header-anchor" href="#dubbo-springboot"><span>Dubbo-SpringBoot</span></a></h3><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/spring/spring-boot/" target="_blank" rel="noopener noreferrer">Dubbo-SpringBoot文档</a></p><p><a href="https://github.com/FirstBloodForJava/dubbo-spring-boot-demo.git" target="_blank" rel="noopener noreferrer">gitbub api例子</a></p><ol><li>启动注册中心，这里使用ZooKeeper；</li><li>创建一个parent项目，里面新建三个模块，api、provider、consumer；</li><li>parent 添加全局依赖管理；</li><li>provider、consumer添加dubbo 依赖及api依赖；</li><li>api 定义服务接口；</li><li>provider 定义服务实现、启动类、服务配置；</li><li>consumer 定义启动类、服务配置；</li><li>定义消费 provider 逻辑。</li><li>启动服务提供者、启动服务消费者。</li></ol><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h2><p><a href="https://dubbo.apache.ac.cn/en/docs3-v2/java-sdk/concepts-and-architecture/" target="_blank" rel="noopener noreferrer">官网文档</a></p>',44)]))}const l=o(i,[["render",b],["__file","Dubbo.html.vue"]]),p=JSON.parse('{"path":"/springcloud/Dubbo.html","title":"Dubbo","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Dubbo简介","slug":"dubbo简介","link":"#dubbo简介","children":[{"level":3,"title":"Dubbo核心特性","slug":"dubbo核心特性","link":"#dubbo核心特性","children":[]}]},{"level":2,"title":"简单使用","slug":"简单使用","link":"#简单使用","children":[{"level":3,"title":"Dubbo-API","slug":"dubbo-api","link":"#dubbo-api","children":[]},{"level":3,"title":"Dubbo-SpringBoot","slug":"dubbo-springboot","link":"#dubbo-springboot","children":[]}]},{"level":2,"title":"架构","slug":"架构","link":"#架构","children":[]}],"git":{"updatedTime":1751694939000,"contributors":[{"name":"oycm","username":"oycm","email":"1164864987@qq.com","commits":1,"url":"https://github.com/oycm"}]},"filePathRelative":"springcloud/Dubbo.md"}');export{l as comp,p as data};
