import{_ as n,c as e,e as s,o as l}from"./app-BIGZvh4f.js";const t={};function p(o,a){return l(),e("div",null,a[0]||(a[0]=[s(`<h2 id="hashmap-源码介绍" tabindex="-1"><a class="header-anchor" href="#hashmap-源码介绍"><span>HashMap 源码介绍</span></a></h2><p>key 的 hash 是根据 <code>HashMap</code> 容量减 1 进行与运算（&amp;），所以要想更均匀的映射，二进制中就需要更多的 1。</p><p>这也是为什么初始化计算 <code>threshold </code> 进行以下操作的原因：保证数组中有更多的的 1。</p><div class="language-java" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line">n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span></span>
<span class="line">n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><p>put 逻辑：</p><ul><li>tab[(key.hash &amp; tab.length - 1)] == null, 在原 hash 表中不存在，直接存</li><li>tab[(key.hash &amp; tab.length - 1)] != null, 但是 key 相等，修改元素</li><li>普通链表中查找元素，存在则修改，不存在则添加，当前链表中数量大于等于 7(TREEIFY_THRESHOLD - 1)，将单向链表先转换成双向链表(TreeNode)，将链表红黑树化。</li></ul><p>hash 表会在两种情况下扩容：初始化，容量超阈值。容量达到 2 ^ 30 时，不会扩容。</p><p>扩容逻辑：</p><ul><li>当前节点没有子节点，移动到 (hash &amp; newTab.length - 1)；</li><li>节点不是 TreeNode，调整老数组链表结构： <ul><li><code>(hash &amp; oldTab.length) == 0 =&gt; hash &amp; 10000</code> 和高位没有交集，该 key 可以落在低位 hash 表</li><li><code>(hash &amp; oldTab.length) == 1</code> 意味着和高位有交集，该 key 需要调整索引，新的索引就是当前 index + oldTab.length</li></ul></li><li>节点是红黑树，则对红黑树进行调整</li></ul><h2 id="juc" tabindex="-1"><a class="header-anchor" href="#juc"><span>JUC</span></a></h2><h3 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h3><h2 id="jvm-调优" tabindex="-1"><a class="header-anchor" href="#jvm-调优"><span>JVM 调优</span></a></h2><p>思路：可参考现有开源项目的 GC 参数来调整自己的应用参数。</p><h2 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h2><h3 id="tcc" tabindex="-1"><a class="header-anchor" href="#tcc"><span>TCC</span></a></h3><p>TCC(Try Confirm Cancel)，在 TCC 模式中，由事务协调器（Transaction Coordinator）来通知各个参与服务（微服务）执行 Confirm、Cancel。</p><p>在 Seata 框架中，这个协调器就是 Seata Server，也称 TC。事务发起方会通过 Seata 的全局事务注解 <code>@GlobalTransactional</code> 开启一个全局事务注解，并注册到 Seata Server 中。同时在 Try 阶段，发起方会将全局唯一事务 ID 发生给调用方，被调用方会向 Seata Server注册分支事务。Try 全部调用成功，事务发起方会通知 Seata Server 提交全局事务，随后 Seata Server 会向各个参与方发送 Confirm 请求。如果 Try 阶段有任何一个参与方失败，事务发起方会通知 Seata Server 回滚全局事务，然后 Seata Server 会向各个参与方发送 Cancel 请求。</p><p>由于网络波动，Confrim 和 Cancel 请求需要保证幂等性。</p><ol><li>数据库乐观锁：通过版本号或状态字段来控制，更新数据时，先检查版本号或状态。</li><li>全局事务唯一 id：每次执行前先检查这个全局事务唯一 id 是否已经被使用。</li><li>状态机：和乐观锁状态字段类似。</li></ol><h2 id="tidb" tabindex="-1"><a class="header-anchor" href="#tidb"><span>TiDB</span></a></h2><h2 id="clickhouse" tabindex="-1"><a class="header-anchor" href="#clickhouse"><span>ClickHouse</span></a></h2>`,21)]))}const c=n(t,[["render",p],["__file","interview.html.vue"]]),r=JSON.parse('{"path":"/tools/interview.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"HashMap 源码介绍","slug":"hashmap-源码介绍","link":"#hashmap-源码介绍","children":[]},{"level":2,"title":"JUC","slug":"juc","link":"#juc","children":[{"level":3,"title":"锁","slug":"锁","link":"#锁","children":[]}]},{"level":2,"title":"JVM 调优","slug":"jvm-调优","link":"#jvm-调优","children":[]},{"level":2,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[{"level":3,"title":"TCC","slug":"tcc","link":"#tcc","children":[]}]},{"level":2,"title":"TiDB","slug":"tidb","link":"#tidb","children":[]},{"level":2,"title":"ClickHouse","slug":"clickhouse","link":"#clickhouse","children":[]}],"git":{"updatedTime":1764600008000,"contributors":[{"name":"ouyangcm","username":"ouyangcm","email":"mingorg@163.com","commits":1,"url":"https://github.com/ouyangcm"},{"name":"oycm","username":"oycm","email":"1164864987@qq.com","commits":1,"url":"https://github.com/oycm"}]},"filePathRelative":"tools/interview.md"}');export{c as comp,r as data};
